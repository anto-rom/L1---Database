-- DROP SCHEMA planet;

CREATE SCHEMA planet AUTHORIZATION postgres;

COMMENT ON SCHEMA planet IS 'Standard public schema';

-- DROP TYPE planet."mpaa_rating";

CREATE TYPE planet."mpaa_rating" AS ENUM (
	'G',
	'PG',
	'PG-13',
	'R',
	'NC-17');

-- DROP DOMAIN planet."year";

CREATE DOMAIN planet."year" AS integer
	CONSTRAINT year_check CHECK (VALUE >= 1901 AND VALUE <= 2155);
-- DROP SEQUENCE planet.actor_actor_id_seq;

CREATE SEQUENCE planet.actor_actor_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.address_address_id_seq;

CREATE SEQUENCE planet.address_address_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.agent_agent_id_seq;

CREATE SEQUENCE planet.agent_agent_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.category_category_id_seq;

CREATE SEQUENCE planet.category_category_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.city_city_id_seq;

CREATE SEQUENCE planet.city_city_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.contact_rate_contact_rate_id_seq;

CREATE SEQUENCE planet.contact_rate_contact_rate_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.country_country_id_seq;

CREATE SEQUENCE planet.country_country_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.customer_customer_id_seq;

CREATE SEQUENCE planet.customer_customer_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.date_date_id_seq;

CREATE SEQUENCE planet.date_date_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.department_department_id_seq;

CREATE SEQUENCE planet.department_department_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.film_film_id_seq;

CREATE SEQUENCE planet.film_film_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.incoming_tickets_incoming_tickets_id_seq;

CREATE SEQUENCE planet.incoming_tickets_incoming_tickets_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.inventory_inventory_id_seq;

CREATE SEQUENCE planet.inventory_inventory_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.language_language_id_seq;

CREATE SEQUENCE planet.language_language_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.payment_payment_id_seq;

CREATE SEQUENCE planet.payment_payment_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.productivity_productivity_id_seq;

CREATE SEQUENCE planet.productivity_productivity_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.quality_evaluations_quality_evaluations_id_seq;

CREATE SEQUENCE planet.quality_evaluations_quality_evaluations_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.rental_rental_id_seq;

CREATE SEQUENCE planet.rental_rental_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.repeat_rate_repeat_rate_id_seq;

CREATE SEQUENCE planet.repeat_rate_repeat_rate_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.staff_staff_id_seq;

CREATE SEQUENCE planet.staff_staff_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.store_store_id_seq;

CREATE SEQUENCE planet.store_store_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 9223372036854775807
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.tickets_sla_tickets_sla_id_seq;

CREATE SEQUENCE planet.tickets_sla_tickets_sla_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;
-- DROP SEQUENCE planet.tl_tl_id_seq;

CREATE SEQUENCE planet.tl_tl_id_seq
	INCREMENT BY 1
	MINVALUE 1
	MAXVALUE 2147483647
	START 1
	CACHE 1
	NO CYCLE;-- planet."date" definition

-- Drop table

-- DROP TABLE planet."date";

CREATE TABLE planet."date" (
	date_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	"Date" date NULL,
	"Month" varchar(20) NULL,
	"Month_number" int4 NULL,
	"Week_number" int4 GENERATED ALWAYS AS (EXTRACT(week FROM "Date" - '3 days'::interval)::integer) STORED NULL,
	"Week_Year" int4 GENERATED ALWAYS AS (EXTRACT(year FROM "Date" - '3 days'::interval)::integer) STORED NULL,
	CONSTRAINT date_pkey PRIMARY KEY (date_id)
);

-- Table Triggers

create trigger trg_update_date_fields before
insert
    or
update
    on
    planet.date for each row execute function planet.update_date_fields();


-- planet.department definition

-- Drop table

-- DROP TABLE planet.department;

CREATE TABLE planet.department (
	department_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	department_name varchar(45) NOT NULL,
	vertical varchar NULL,
	department_group varchar NULL,
	team_hierarchy varchar NULL,
	CONSTRAINT department_pkey PRIMARY KEY (department_id)
);


-- planet.tl definition

-- Drop table

-- DROP TABLE planet.tl;

CREATE TABLE planet.tl (
	tl_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	first_name varchar(45) NOT NULL,
	last_name varchar(45) NOT NULL,
	CONSTRAINT tl_pkey PRIMARY KEY (tl_id)
);


-- planet."VoC" definition

-- Drop table

-- DROP TABLE planet."VoC";

CREATE TABLE planet."VoC" (
	"VoC_ID" numeric NOT NULL,
	"Date" date NULL,
	case_number int8 NULL,
	survey_name text NULL,
	"Premium" bool NULL,
	account_name text NULL,
	department_id int4 NULL,
	vertical text NULL,
	case_origin text NULL,
	case_reason text NULL,
	case_subreason text NULL,
	subject text NULL,
	agent_id int4 NULL,
	country text NULL,
	"NPS_type" text NULL,
	survey_resolution numeric NULL,
	"NPS" numeric NULL,
	"NPS_Reason" text NULL,
	"NES" numeric NULL,
	"CSAT_Service" numeric NULL,
	"CSAT_Product" numeric NULL,
	"HC_Score" numeric NULL,
	date_id int4 NULL,
	customer_comment varchar NULL,
	contact_name varchar NULL,
	email varchar NULL,
	"chain" varchar NULL,
	department_name varchar NULL,
	team_hierarchy varchar NULL,
	customer_comment_detractor varchar NULL,
	department_group varchar NULL,
	CONSTRAINT "VoC_ID" UNIQUE ("VoC_ID"),
	CONSTRAINT voc_date_fk FOREIGN KEY (date_id) REFERENCES planet."date"(date_id),
	CONSTRAINT voc_department_fk FOREIGN KEY (department_id) REFERENCES planet.department(department_id)
);


-- planet.agent definition

-- Drop table

-- DROP TABLE planet.agent;

CREATE TABLE planet.agent (
	agent_id int4 NOT NULL,
	first_name varchar(45) NOT NULL,
	last_name varchar(45) NOT NULL,
	tl_id int4 NOT NULL,
	department_id int4 NOT NULL,
	CONSTRAINT agent_unique UNIQUE (agent_id),
	CONSTRAINT agent_department_fk FOREIGN KEY (department_id) REFERENCES planet.department(department_id),
	CONSTRAINT agent_tl_fk FOREIGN KEY (tl_id) REFERENCES planet.tl(tl_id)
);


-- planet.call_performance definition

-- Drop table

-- DROP TABLE planet.call_performance;

CREATE TABLE planet.call_performance (
	date_id int4 NULL,
	department_id int4 NULL,
	inbound int4 NULL,
	sla numeric NULL,
	aba numeric NULL,
	asa time NULL,
	aht time NULL,
	CONSTRAINT call_performance_date_fk FOREIGN KEY (date_id) REFERENCES planet."date"(date_id)
);


-- planet.contact_rate definition

-- Drop table

-- DROP TABLE planet.contact_rate;

CREATE TABLE planet.contact_rate (
	contact_rate_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	department_id int4 NOT NULL,
	total_number numeric NOT NULL,
	"Date" date NULL,
	date_id int4 NULL,
	CONSTRAINT contact_rate_pkey PRIMARY KEY (contact_rate_id),
	CONSTRAINT contact_rate_date_fk FOREIGN KEY (date_id) REFERENCES planet."date"(date_id)
);


-- planet.incoming_tickets definition

-- Drop table

-- DROP TABLE planet.incoming_tickets;

CREATE TABLE planet.incoming_tickets (
	incoming_tickets_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	department_id int4 NOT NULL,
	date_id int4 NOT NULL,
	ticket_total int4 NULL,
	"Date" date NULL,
	CONSTRAINT incoming_tickets_pkey PRIMARY KEY (incoming_tickets_id),
	CONSTRAINT incoming_tickets_date_fk FOREIGN KEY (date_id) REFERENCES planet."date"(date_id),
	CONSTRAINT incoming_tickets_department_fk FOREIGN KEY (department_id) REFERENCES planet.department(department_id)
);


-- planet.outbounds definition

-- Drop table

-- DROP TABLE planet.outbounds;

CREATE TABLE planet.outbounds (
	outbound_id int4 NOT NULL,
	agent_id int4 NULL,
	"Date" date NULL,
	total_outbounds numeric NULL,
	department_id int4 NULL,
	CONSTRAINT outbounds_pk PRIMARY KEY (outbound_id),
	CONSTRAINT outbounds_agent_fk FOREIGN KEY (agent_id) REFERENCES planet.agent(agent_id),
	CONSTRAINT outbounds_department_fk FOREIGN KEY (department_id) REFERENCES planet.department(department_id)
);


-- planet.productivity definition

-- Drop table

-- DROP TABLE planet.productivity;

CREATE TABLE planet.productivity (
	productivity_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	department_id int4 NOT NULL,
	agent_id int4 NOT NULL,
	productivity_total numeric NULL,
	"Date" date NULL,
	CONSTRAINT productivity_pkey PRIMARY KEY (productivity_id),
	CONSTRAINT productivity_agent_fk FOREIGN KEY (agent_id) REFERENCES planet.agent(agent_id)
);


-- planet.quality_evaluations definition

-- Drop table

-- DROP TABLE planet.quality_evaluations;

CREATE TABLE planet.quality_evaluations (
	quality_evaluations_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	department_id int4 NOT NULL,
	agent_id int4 NOT NULL,
	"Date" date NULL,
	quality_total numeric NULL,
	case_number int8 NULL,
	evaluator int4 NULL,
	case_type varchar NULL,
	CONSTRAINT quality_evaluations_pkey PRIMARY KEY (quality_evaluations_id),
	CONSTRAINT quality_evaluations_agent_fk FOREIGN KEY (agent_id) REFERENCES planet.agent(agent_id),
	CONSTRAINT quality_evaluations_department_fk FOREIGN KEY (department_id) REFERENCES planet.department(department_id)
);


-- planet.repeat_rate definition

-- Drop table

-- DROP TABLE planet.repeat_rate;

CREATE TABLE planet.repeat_rate (
	repeat_rate_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	department_id int4 NOT NULL,
	agent_id int4 NOT NULL,
	"Date" date NULL,
	"3_repeats" int4 NULL,
	all_touchpoints int4 NULL,
	"Month" varchar NULL,
	CONSTRAINT repeat_rate_pkey PRIMARY KEY (repeat_rate_id),
	CONSTRAINT repeat_rate_agent_fk FOREIGN KEY (agent_id) REFERENCES planet.agent(agent_id)
);

-- Table Triggers

create trigger trg_set_month_name before
insert
    or
update
    on
    planet.repeat_rate for each row execute function planet.set_month_name();


-- planet.tickets_sla definition

-- Drop table

-- DROP TABLE planet.tickets_sla;

CREATE TABLE planet.tickets_sla (
	tickets_sla_id int4 GENERATED BY DEFAULT AS IDENTITY( INCREMENT BY 1 MINVALUE 1 MAXVALUE 2147483647 START 1 CACHE 1 NO CYCLE) NOT NULL,
	department_id int4 NOT NULL,
	date_id int4 NULL,
	sla_ticket numeric NULL,
	CONSTRAINT tickets_sla_pkey PRIMARY KEY (tickets_sla_id),
	CONSTRAINT tickets_sla_department_fk FOREIGN KEY (department_id) REFERENCES planet.department(department_id)
);


-- planet."CSAT_Service_monthly_agent" source

CREATE OR REPLACE VIEW planet."CSAT_Service_monthly_agent"
AS SELECT concat(a.first_name, ' ', a.last_name) AS agent_name,
    d2."Month",
    d.department_name AS name,
    d2."Week_Year" AS "Year",
    count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END) AS positive_scores,
    count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END) AS negative_scores,
    count(v."CSAT_Service") AS total_scores,
    round(count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."CSAT_Service"), 0)::numeric * 100::numeric, 2) AS "CSAT_Service"
   FROM planet."VoC" v
     JOIN planet.department d ON d.department_id = v.department_id
     JOIN planet.date d2 ON d2."Date" = v."Date"
     JOIN planet.agent a ON a.agent_id = v.agent_id
  WHERE v.department_id = ANY (ARRAY[1, 2, 3])
  GROUP BY a.first_name, a.last_name, d2."Month", d.department_name, d2."Week_Year"
  ORDER BY a.first_name, a.last_name, d2."Month";


-- planet."Call_performance_per_month" source

CREATE OR REPLACE VIEW planet."Call_performance_per_month"
AS SELECT dep.department_name AS "Department",
    d."Month",
    d."Month_number",
    sum(cp.inbound) AS total_inbound,
    avg(cp.inbound) AS avg_inbound,
    avg(cp.sla) AS avg_sla,
    avg(cp.aba) AS avg_aba,
    avg(cp.asa::interval) AS avg_asa,
    avg(cp.aht::interval) AS avg_aht
   FROM planet.call_performance cp
     JOIN planet.date d ON cp.date_id = d.date_id
     JOIN planet.department dep ON dep.department_id = cp.department_id
  GROUP BY dep.department_name, d."Month", d."Month_number"
  ORDER BY dep.department_name, d."Month_number";


-- planet."NES_per_agent" source

CREATE OR REPLACE VIEW planet."NES_per_agent"
AS SELECT d2."Month",
    d.department_name AS department,
    concat(a.first_name, ' ', a.last_name) AS agent_name,
    count(
        CASE
            WHEN v."NES" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS positive_scores,
    count(
        CASE
            WHEN v."NES" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS negative_scores,
    count(v."NES")::numeric AS total_scores,
    round((count(
        CASE
            WHEN v."NES" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NES"), 0)::numeric - count(
        CASE
            WHEN v."NES" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NES"), 0)::numeric) * 100::numeric, 2) AS "NES"
   FROM planet."VoC" v
     JOIN planet.department d ON d.department_id = v.department_id
     JOIN planet.date d2 ON d2."Date" = v."Date"
     JOIN planet.agent a ON a.agent_id = v.agent_id
  WHERE v.department_id = ANY (ARRAY[1, 2, 3])
  GROUP BY d2."Month", d.department_id, (concat(a.first_name, ' ', a.last_name));


-- planet."NPS_per_month" source

CREATE OR REPLACE VIEW planet."NPS_per_month"
AS SELECT d.department_name AS name,
    d2."Month",
    count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[9::numeric, 10::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS positive_scores,
    count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[1::numeric, 2::numeric, 3::numeric, 4::numeric, 5::numeric, 6::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS negative_scores,
    count(v."NPS")::numeric AS total_scores,
    round((count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[8::numeric, 9::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NPS"), 0)::numeric - count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NES"), 0)::numeric) * 100::numeric, 2) AS "NPS"
   FROM planet."VoC" v
     JOIN planet.department d ON d.department_id = v.department_id
     JOIN planet.date d2 ON d2."Date" = v."Date"
  GROUP BY d.department_name, d2."Month";


-- planet."Productivity_per_Month" source

CREATE OR REPLACE VIEW planet."Productivity_per_Month"
AS SELECT concat(a.first_name, ' ', a.last_name) AS agent_name,
    avg(p.productivity_total) AS case_average,
    d."Month" AS month
   FROM planet.productivity p
     JOIN planet.agent a ON a.agent_id = p.agent_id
     JOIN planet.date d ON d."Date" = p."Date"
  GROUP BY (concat(a.first_name, ' ', a.last_name)), d."Month";


-- planet."RR_yesterday" source

CREATE OR REPLACE VIEW planet."RR_yesterday"
AS SELECT rr."Date",
    sum(rr."3_repeats") AS repeats,
    sum(rr.all_touchpoints) AS touchpoints,
    rr.department_id,
    d.department_name AS name,
    sum(rr."3_repeats")::numeric * 100.0 / NULLIF(sum(rr.all_touchpoints), 0)::numeric AS rr
   FROM planet.repeat_rate rr
     JOIN planet.department d ON d.department_id = rr.department_id
  WHERE rr."Date" = (CURRENT_DATE - '1 day'::interval)
  GROUP BY rr."Date", rr.department_id, d.department_name;


-- planet."VoC_Not_Resolved" source

CREATE OR REPLACE VIEW planet."VoC_Not_Resolved"
AS SELECT v.survey_resolution,
    v."NPS_type",
    d.department_name AS name,
    d2."Month",
    d2."Week_number",
    d2."Date",
    v.survey_name,
    concat(a.first_name, ' ', a.last_name) AS concat,
    v.case_number,
    v."Premium",
    v.case_origin,
    v.case_reason
   FROM planet."VoC" v
     JOIN planet.department d ON d.department_id = v.department_id
     JOIN planet.date d2 ON d2."Date" = v."Date"
     JOIN planet.agent a ON a.agent_id = v.agent_id
  WHERE v.survey_resolution = '0'::numeric OR v."NPS_type" = 'Detractor'::text
  GROUP BY v.survey_resolution, v."NPS_type", d.department_name, d2."Month", d2."Week_number", d2."Date", v.survey_name, a.first_name, a.last_name, v.case_number, v."Premium", v.case_origin, v.case_reason
  ORDER BY d2."Date";


-- planet."VoC_Reasons_per_month" source

CREATE OR REPLACE VIEW planet."VoC_Reasons_per_month"
AS SELECT d."Month",
    dep.department_name AS name,
    d."Week_Year" AS "Year",
    d."Month_number",
    v."NPS_type",
    v."NPS_Reason"
   FROM planet."VoC" v
     JOIN planet.date d ON d."Date" = v."Date"
     JOIN planet.department dep ON dep.department_id = v.department_id
  GROUP BY d."Month", dep.department_name, d."Week_Year", d."Month_number", v."NPS_type", v."NPS_Reason"
  ORDER BY d."Week_Year", d."Month_number";


-- planet."VoC_Results_2025" source

CREATE OR REPLACE VIEW planet."VoC_Results_2025"
AS SELECT d2."Month",
    d.department_name AS name,
    d2."Week_Year" AS "Year",
    count(
        CASE
            WHEN v.survey_resolution = '1'::numeric THEN 1
            ELSE NULL::integer
        END) AS "Resolved",
    count(v.survey_resolution) AS "Not_resolved",
    round(count(
        CASE
            WHEN v.survey_resolution = '1'::numeric THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v.survey_resolution), 0)::numeric * 100::numeric, 2) AS "Resolution_total",
    count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[9::numeric, 10::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS nps_promoter,
    count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[1::numeric, 2::numeric, 3::numeric, 4::numeric, 5::numeric, 6::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS nps_detractor,
    count(v."NPS")::numeric AS nps_total,
    round((count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[8::numeric, 9::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NPS"), 0)::numeric - count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NES"), 0)::numeric) * 100::numeric, 2) AS "NPS",
    count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END) AS csat_positive,
    count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END) AS csat_negative,
    count(v."CSAT_Service") AS csat_total,
    round(count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."CSAT_Service"), 0)::numeric * 100::numeric, 2) AS "CSAT_Service",
    count(
        CASE
            WHEN v."NES" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END) AS nes_positive,
    count(
        CASE
            WHEN v."NES" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END) AS nes_negative,
    count(v."NES") AS nes_total,
    round(count(
        CASE
            WHEN v."NES" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NES"), 0)::numeric * 100::numeric, 2) AS "NES",
    count(
        CASE
            WHEN v."CSAT_Product" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END) AS "Product_negative",
    count(v."CSAT_Product") AS product_total,
    round(count(
        CASE
            WHEN v."CSAT_Product" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."CSAT_Product"), 0)::numeric * 100::numeric, 2) AS "CSAT_Product"
   FROM planet."VoC" v
     JOIN planet.department d ON d.department_id = v.department_id
     JOIN planet.date d2 ON d2."Date" = v."Date"
     JOIN planet.agent a ON a.agent_id = v.agent_id
  WHERE d2."Week_Year" = 2025
  GROUP BY d2."Month", d.department_name, d2."Week_Year", d2."Month_number"
  ORDER BY d.department_name, d2."Month_number";


-- planet."VoC_Weekly_2025" source

CREATE OR REPLACE VIEW planet."VoC_Weekly_2025"
AS SELECT d2."Week_number",
    d2."Week_Year",
    d.department_name AS name,
    count(
        CASE
            WHEN v.survey_resolution = '1'::numeric THEN 1
            ELSE NULL::integer
        END) AS "Resolved",
    count(v.survey_resolution) AS "Not_resolved",
    round(count(
        CASE
            WHEN v.survey_resolution = '1'::numeric THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v.survey_resolution), 0)::numeric * 100::numeric, 2) AS "Resolution_total",
    count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[9::numeric, 10::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS nps_promoter,
    count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[1::numeric, 2::numeric, 3::numeric, 4::numeric, 5::numeric, 6::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric AS nps_detractor,
    count(v."NPS")::numeric AS nps_total,
    round((count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[8::numeric, 9::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NPS"), 0)::numeric - count(
        CASE
            WHEN v."NPS" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NES"), 0)::numeric) * 100::numeric, 2) AS "NPS",
    count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END) AS csat_positive,
    count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END) AS csat_negative,
    count(v."CSAT_Service") AS csat_total,
    round(count(
        CASE
            WHEN v."CSAT_Service" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."CSAT_Service"), 0)::numeric * 100::numeric, 2) AS "CSAT_Service",
    count(
        CASE
            WHEN v."NES" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END) AS nes_positive,
    count(
        CASE
            WHEN v."NES" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END) AS nes_negative,
    count(v."NES") AS nes_total,
    round(count(
        CASE
            WHEN v."NES" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."NES"), 0)::numeric * 100::numeric, 2) AS "NES",
    count(
        CASE
            WHEN v."CSAT_Product" = ANY (ARRAY[1::numeric, 2::numeric]) THEN 1
            ELSE NULL::integer
        END) AS "Product_negative",
    count(v."CSAT_Product") AS product_total,
    round(count(
        CASE
            WHEN v."CSAT_Product" = ANY (ARRAY[4::numeric, 5::numeric]) THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v."CSAT_Product"), 0)::numeric * 100::numeric, 2) AS "CSAT_Product"
   FROM planet."VoC" v
     JOIN planet.department d ON d.department_id = v.department_id
     JOIN planet.date d2 ON d2."Date" = v."Date"
     JOIN planet.agent a ON a.agent_id = v.agent_id
  WHERE d2."Week_Year" = 2025 AND (d.department_id = ANY (ARRAY[1, 2, 3]))
  GROUP BY d2."Week_number", d.department_name, d2."Week_Year"
  ORDER BY d.department_name, d2."Week_number";


-- planet.contact_per_month source

CREATE OR REPLACE VIEW planet.contact_per_month
AS SELECT d.department_name AS name,
    avg(cr.total_number) AS avg,
    d2."Month"
   FROM planet.contact_rate cr
     JOIN planet.department d ON d.department_id = cr.department_id
     JOIN planet.date d2 ON d2.date_id = cr.date_id
  GROUP BY d.department_name, d2."Month";


-- planet.survey_resolution_per_month source

CREATE OR REPLACE VIEW planet.survey_resolution_per_month
AS SELECT concat(a.first_name, ' ', a.last_name) AS agent_name,
    d2."Month",
    count(
        CASE
            WHEN v.survey_resolution = 1::numeric THEN 1
            ELSE NULL::integer
        END) AS resolved,
    count(
        CASE
            WHEN v.survey_resolution = 0::numeric THEN 1
            ELSE NULL::integer
        END) AS not_resolved,
    count(v.survey_resolution) AS total_scores,
    round(count(
        CASE
            WHEN v.survey_resolution = 1::numeric THEN 1
            ELSE NULL::integer
        END)::numeric / NULLIF(count(v.survey_resolution), 0)::numeric * 100::numeric, 2) AS survey_resolution
   FROM planet."VoC" v
     JOIN planet.department d ON d.department_id = v.department_id
     JOIN planet.date d2 ON d2."Date" = v."Date"
     JOIN planet.agent a ON a.agent_id = v.agent_id
  WHERE v.department_id = ANY (ARRAY[1, 2, 3])
  GROUP BY a.first_name, a.last_name, d2."Month"
  ORDER BY a.first_name, a.last_name, d2."Month";


-- planet.tickets_monthly source

CREATE OR REPLACE VIEW planet.tickets_monthly
AS SELECT d."Month",
    sum(it.ticket_total) AS sum,
    dp.department_name AS name
   FROM planet.incoming_tickets it
     JOIN planet.date d ON it.date_id = d.date_id
     JOIN planet.department dp ON dp.department_id = it.department_id
  GROUP BY d."Month", dp.department_name;



-- DROP FUNCTION planet."_group_concat"(text, text);

CREATE OR REPLACE FUNCTION planet._group_concat(text, text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
SELECT CASE
  WHEN $2 IS NULL THEN $1
  WHEN $1 IS NULL THEN $2
  ELSE $1 || ', ' || $2
END
$function$
;

-- DROP FUNCTION planet.film_in_stock(in int4, in int4, out int4);

CREATE OR REPLACE FUNCTION planet.film_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer)
 RETURNS SETOF integer
 LANGUAGE sql
AS $function$
     SELECT inventory_id
     FROM inventory
     WHERE film_id = $1
     AND store_id = $2
     AND inventory_in_stock(inventory_id);
$function$
;

-- DROP FUNCTION planet.film_not_in_stock(in int4, in int4, out int4);

CREATE OR REPLACE FUNCTION planet.film_not_in_stock(p_film_id integer, p_store_id integer, OUT p_film_count integer)
 RETURNS SETOF integer
 LANGUAGE sql
AS $function$
    SELECT inventory_id
    FROM inventory
    WHERE film_id = $1
    AND store_id = $2
    AND NOT inventory_in_stock(inventory_id);
$function$
;

-- DROP FUNCTION planet.get_customer_balance(int4, timestamp);

CREATE OR REPLACE FUNCTION planet.get_customer_balance(p_customer_id integer, p_effective_date timestamp without time zone)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
       --#OK, WE NEED TO CALCULATE THE CURRENT BALANCE GIVEN A CUSTOMER_ID AND A DATE
       --#THAT WE WANT THE BALANCE TO BE EFFECTIVE FOR. THE BALANCE IS:
       --#   1) RENTAL FEES FOR ALL PREVIOUS RENTALS
       --#   2) ONE DOLLAR FOR EVERY DAY THE PREVIOUS RENTALS ARE OVERDUE
       --#   3) IF A FILM IS MORE THAN RENTAL_DURATION * 2 OVERDUE, CHARGE THE REPLACEMENT_COST
       --#   4) SUBTRACT ALL PAYMENTS MADE BEFORE THE DATE SPECIFIED
DECLARE
    v_rentfees DECIMAL(5,2); --#FEES PAID TO RENT THE VIDEOS INITIALLY
    v_overfees INTEGER;      --#LATE FEES FOR PRIOR RENTALS
    v_payments DECIMAL(5,2); --#SUM OF PAYMENTS MADE PREVIOUSLY
BEGIN
    SELECT COALESCE(SUM(film.rental_rate),0) INTO v_rentfees
    FROM film, inventory, rental
    WHERE film.film_id = inventory.film_id
      AND inventory.inventory_id = rental.inventory_id
      AND rental.rental_date <= p_effective_date
      AND rental.customer_id = p_customer_id;

    SELECT COALESCE(SUM(IF((rental.return_date - rental.rental_date) > (film.rental_duration * '1 day'::interval),
        ((rental.return_date - rental.rental_date) - (film.rental_duration * '1 day'::interval)),0)),0) INTO v_overfees
    FROM rental, inventory, film
    WHERE film.film_id = inventory.film_id
      AND inventory.inventory_id = rental.inventory_id
      AND rental.rental_date <= p_effective_date
      AND rental.customer_id = p_customer_id;

    SELECT COALESCE(SUM(payment.amount),0) INTO v_payments
    FROM payment
    WHERE payment.payment_date <= p_effective_date
    AND payment.customer_id = p_customer_id;

    RETURN v_rentfees + v_overfees - v_payments;
END
$function$
;

-- DROP AGGREGATE planet.group_concat(text);

CREATE OR REPLACE AGGREGATE planet.group_concat(pg_catalog.text) (
	SFUNC = planet._group_concat,
	STYPE = text
);

-- DROP FUNCTION planet.inventory_held_by_customer(int4);

CREATE OR REPLACE FUNCTION planet.inventory_held_by_customer(p_inventory_id integer)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_customer_id INTEGER;
BEGIN

  SELECT customer_id INTO v_customer_id
  FROM rental
  WHERE return_date IS NULL
  AND inventory_id = p_inventory_id;

  RETURN v_customer_id;
END $function$
;

-- DROP FUNCTION planet.inventory_in_stock(int4);

CREATE OR REPLACE FUNCTION planet.inventory_in_stock(p_inventory_id integer)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_rentals INTEGER;
    v_out     INTEGER;
BEGIN
    -- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE
    -- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED

    SELECT count(*) INTO v_rentals
    FROM rental
    WHERE inventory_id = p_inventory_id;

    IF v_rentals = 0 THEN
      RETURN TRUE;
    END IF;

    SELECT COUNT(rental_id) INTO v_out
    FROM inventory LEFT JOIN rental USING(inventory_id)
    WHERE inventory.inventory_id = p_inventory_id
    AND rental.return_date IS NULL;

    IF v_out > 0 THEN
      RETURN FALSE;
    ELSE
      RETURN TRUE;
    END IF;
END $function$
;

-- DROP FUNCTION planet.last_day(timestamp);

CREATE OR REPLACE FUNCTION planet.last_day(timestamp without time zone)
 RETURNS date
 LANGUAGE sql
 IMMUTABLE STRICT
AS $function$
  SELECT CASE
    WHEN EXTRACT(MONTH FROM $1) = 12 THEN
      (((EXTRACT(YEAR FROM $1) + 1) operator(pg_catalog.||) '-01-01')::date - INTERVAL '1 day')::date
    ELSE
      ((EXTRACT(YEAR FROM $1) operator(pg_catalog.||) '-' operator(pg_catalog.||) (EXTRACT(MONTH FROM $1) + 1) operator(pg_catalog.||) '-01')::date - INTERVAL '1 day')::date
    END
$function$
;

-- DROP FUNCTION planet.last_updated();

CREATE OR REPLACE FUNCTION planet.last_updated()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.last_update = CURRENT_TIMESTAMP;
    RETURN NEW;
END $function$
;

-- DROP FUNCTION planet.set_month_name();

CREATE OR REPLACE FUNCTION planet.set_month_name()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW."Month" := TO_CHAR(NEW."Date", 'FMMonth');
    RETURN NEW;
END;
$function$
;

-- DROP FUNCTION planet.update_date_fields();

CREATE OR REPLACE FUNCTION planet.update_date_fields()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW."Month" := TO_CHAR(NEW."Date", 'Month');
    NEW."Month_number" := EXTRACT(MONTH FROM NEW."Date")::int;
    RETURN NEW;
END;
$function$
;

